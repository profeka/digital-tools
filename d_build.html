<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diédrico Creator - Diseña tu Nombre</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background-color: #f0fdf4; }
        .grid-cell:hover { transform: scale(1.05); z-index: 10; border-color: rgba(0,0,0,0.5); }
        
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?deps=react@18.2.0",
        "lucide-react": "https://esm.sh/lucide-react@0.294.0?deps=react@18.2.0",
        "three": "https://esm.sh/three@0.160.0",
        "three/examples/jsm/controls/OrbitControls.js": "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js?deps=three@0.160.0",
        "three/examples/jsm/utils/BufferGeometryUtils.js": "https://esm.sh/three@0.160.0/examples/jsm/utils/BufferGeometryUtils.js?deps=three@0.160.0",
        "html2canvas": "https://esm.sh/html2canvas@1.4.1"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Grid, MousePointer2, RefreshCw, Eraser, Download, Image as ImageIcon, Box, Triangle, Type, Camera, Trash2, Info } from 'lucide-react';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
        import html2canvas from 'html2canvas';

        // --- CONSTANTS & UTILS ---
        const U = 15; // Unit size for 3D blocks
        
        const PALETTE = {
            BG: '#f0fdf4',
            STROKE: '#000000',
            FACE_TOP: '#86efac',     // Green-300
            FACE_FRONT: '#f9a8d4',   // Pink-300
            FACE_SIDE: '#7dd3fc',    // Sky-300
            FACE_SIDE_LEFT: '#fdba74', 
            FACE_BACK: '#818cf8',
            FACE_BOTTOM: '#059669'
        };

        const createEmptyGridState = (res) => ({
            cells: new Array(res * res).fill(0),
            v: new Array(res * (res - 1)).fill(0), // Vertical edges (unused for synthesis logic but kept for structure)
            h: new Array((res - 1) * res).fill(0)  // Horizontal edges
        });

        // --- GEOMETRY GENERATION ---
        
        // Converts 2D grid inputs into 3D Voxel coordinates
        const calculateVoxelsFromViews = (alzado, planta, perfil, res) => {
            const voxels = [];
            // Coordinate system: X (Left-Right), Y (Down-Up), Z (Front-Back)
            // Alzado (Front view) maps X and Y.
            // Planta (Top view) maps X and Z.
            // Perfil (Side view) maps Z and Y.

            for (let x = 0; x < res; x++) {
                for (let y = 0; y < res; y++) {
                    for (let z = 0; z < res; z++) {
                        // Indices for flat arrays
                        // Alzado: Y is inverted visually (bottom is row res-1)
                        const valA = alzado[(res - 1 - y) * res + x];
                        const valP = planta[z * res + x];
                        const valS = perfil[(res - 1 - y) * res + (res - 1 - z)];

                        // Intersection logic: A block exists if it exists in ALL three views at that coordinate
                        if (valA > 0 && valP > 0 && valS > 0) {
                            let type = 1; // Default cube
                            
                            // Simple logic for slopes (prioritize Front/Side shapes)
                            if (valA >= 2) type = 10 + valA; // Front-facing wedges
                            else if (valS >= 2) type = 20 + valS; // Side-facing wedges
                            
                            voxels.push([x, y, z, type]);
                        }
                    }
                }
            }
            return voxels;
        };

        const createWedgeGeometry = (shapeType, axis) => {
            const v3 = (p, d) => {
                if (axis === 'z') return [p[0] - 0.5, p[1] - 0.5, d - 0.5];
                return [d - 0.5, p[1] - 0.5, 0.5 - p[0]]; 
            }
            const pts = [];
            const addTri = (a, b, c) => pts.push(...a.map(v=>v*U), ...b.map(v=>v*U), ...c.map(v=>v*U));
            const addQuad = (a, b, c, d) => { addTri(a,b,c); addTri(a,c,d); }
            
            // 0,0 is bottom-left
            let p0n, p1n, p2n; // Triangle points on the face
            if (shapeType === 2) { p0n=[0,0]; p1n=[1,0]; p2n=[0,1]; } // Bottom-Left filled
            else if (shapeType === 3) { p0n=[0,0]; p1n=[1,0]; p2n=[1,1]; } // Bottom-Right filled
            else if (shapeType === 4) { p0n=[1,0]; p1n=[1,1]; p2n=[0,1]; } // Top-Right filled
            else { p0n=[0,0]; p1n=[1,1]; p2n=[0,1]; } // Top-Left filled

            const A0 = v3(p0n, 0), B0 = v3(p1n, 0), C0 = v3(p2n, 0);
            const A1 = v3(p0n, 1), B1 = v3(p1n, 1), C1 = v3(p2n, 1);

            addTri(A0, C0, B0); // Front 
            addTri(A1, B1, C1); // Back
            addQuad(A0, B0, B1, A1); 
            addQuad(B0, C0, C1, B1); 
            addQuad(C0, A0, A1, C1); 

            const buffer = new THREE.BufferGeometry();
            buffer.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
            return buffer;
        };

        const generateVoxelMesh = (voxels, res) => {
            if(!voxels || voxels.length === 0) return null;
            const geometries = [];
            const center = new THREE.Vector3((res * U) / 2 - U/2, (res * U) / 2 - U/2, (res * U) / 2 - U/2);

            voxels.forEach(([x, y, z, type]) => {
                let geo;
                // Type 1: Cube
                if (!type || type === 1) {
                    geo = new THREE.BoxGeometry(U, U, U).toNonIndexed();
                } else if (type >= 12 && type <= 15) {
                    geo = createWedgeGeometry(type - 10, 'z'); // Front facing wedges
                } else if (type >= 22 && type <= 25) {
                    geo = createWedgeGeometry(type - 20, 'x'); // Side facing wedges
                } else {
                    geo = new THREE.BoxGeometry(U, U, U).toNonIndexed();
                }
                
                // Cleanup attributes
                if (geo.getAttribute('normal')) geo.deleteAttribute('normal');
                if (geo.getAttribute('uv')) geo.deleteAttribute('uv');

                geo.translate(x * U - center.x, y * U - center.y, z * U - center.z);
                geometries.push(geo);
            });

            if(geometries.length === 0) return null;
            let mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
            mergedGeo.computeVertexNormals();

            const colors = [];
            const pos = mergedGeo.attributes.position;
            const count = pos.count;
            const normal = mergedGeo.attributes.normal;
            const _normal = new THREE.Vector3();

            for (let i = 0; i < count; i++) {
                _normal.fromBufferAttribute(normal, i);
                let colorHex = PALETTE.FACE_FRONT;
                
                // Color faces based on normal direction
                if (_normal.y > 0.5) colorHex = PALETTE.FACE_TOP;
                else if (_normal.y < -0.5) colorHex = PALETTE.FACE_BOTTOM;
                else if (_normal.z > 0.5) colorHex = PALETTE.FACE_FRONT;
                else if (_normal.z < -0.5) colorHex = PALETTE.FACE_BACK;
                else if (_normal.x > 0.5) colorHex = PALETTE.FACE_SIDE;
                else if (_normal.x < -0.5) colorHex = PALETTE.FACE_SIDE_LEFT;

                const c = new THREE.Color(colorHex);
                colors.push(c.r, c.g, c.b);
            }

            mergedGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.MeshBasicMaterial({ vertexColors: true });
            const mesh = new THREE.Mesh(mergedGeo, material);
            
            // Add black outlines
            const edges = new THREE.EdgesGeometry(mergedGeo, 1); // threshold angle
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: PALETTE.STROKE, linewidth: 2 }));
            mesh.add(line);

            return mesh;
        };

        // --- 3D VIEWER COMPONENT ---
        const VoxelViewer = ({ voxels, gridResolution }) => {
            const mountRef = useRef(null);
            const controlsRef = useRef(null);
            const sceneRef = useRef(null);
            const meshRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);

            useEffect(() => {
                if (!mountRef.current) return;

                // Scene Setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color('#FFFFFF'); 
                sceneRef.current = scene;

                const w = mountRef.current.clientWidth;
                const h = mountRef.current.clientHeight;
                const aspect = w / h;

                // Orthographic Camera for technical drawing feel
                const camera = new THREE.OrthographicCamera(-80 * aspect, 80 * aspect, 80, -80, 1, 1000);
                camera.position.set(100, 81.6, 100); // Isometric angle
                camera.lookAt(0,0,0);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                renderer.setSize(w, h);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controlsRef.current = controls;

                // Animation Loop
                let animFrame;
                const animate = () => {
                    animFrame = requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                const handleResize = () => {
                    if (!mountRef.current || !cameraRef.current || !rendererRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    const aspect = w / h;
                    cameraRef.current.left = -80 * aspect;
                    cameraRef.current.right = 80 * aspect;
                    cameraRef.current.top = 80;
                    cameraRef.current.bottom = -80;
                    cameraRef.current.updateProjectionMatrix();
                    rendererRef.current.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(animFrame);
                    if (mountRef.current && renderer.domElement) mountRef.current.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, []);

            // Update Mesh
            useEffect(() => {
                if (!sceneRef.current) return;

                // Clear old mesh
                if (meshRef.current) {
                    sceneRef.current.remove(meshRef.current);
                    meshRef.current.geometry.dispose();
                    meshRef.current.material.dispose();
                }

                // Add Helpers (Grid/Axis)
                // We'll remove old helpers first just in case
                sceneRef.current.children.forEach(c => {
                    if(c.type === 'AxesHelper' || (c.type === 'Mesh' && c.isGhost)) sceneRef.current.remove(c);
                });

                const boxSize = gridResolution * U;
                // Ghost box (bounding box)
                const ghostGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                const ghostMat = new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: true, opacity: 0.3, transparent: true });
                const ghost = new THREE.Mesh(ghostGeo, ghostMat);
                ghost.isGhost = true;
                sceneRef.current.add(ghost);

                const mesh = generateVoxelMesh(voxels, gridResolution);
                
                if (mesh) {
                    sceneRef.current.add(mesh);
                    meshRef.current = mesh;
                }
            }, [voxels, gridResolution]);

            return <div ref={mountRef} className="w-full h-full cursor-move" />;
        };

        // --- 2D GRID COMPONENT ---
        const ProjectionGrid = ({ title, color, data, resolution, tool, onCellClick, validityMask }) => {
            const isDragging = useRef(false);
            const paintValue = useRef(0);

            useEffect(() => {
                const handleUp = () => isDragging.current = false;
                window.addEventListener('mouseup', handleUp);
                return () => window.removeEventListener('mouseup', handleUp);
            }, []);

            const handleMouseDown = (idx) => {
                isDragging.current = true;
                const current = data.cells[idx];
                
                // Logic: 
                // If using Cube tool: Toggle 0 <-> 1
                // If using Triangle tool: Cycle 2->3->4->5->2 (if empty, start at 2)
                
                let next = 0;
                if (tool === 'cube') {
                    next = current === 0 ? 1 : 0;
                } else {
                    if (current < 2) next = 2; 
                    else if (current < 5) next = current + 1; 
                    else next = 2; // Loop shapes
                }
                
                paintValue.current = next;
                onCellClick(idx, next);
            };

            const handleMouseEnter = (idx) => {
                if (isDragging.current) {
                    onCellClick(idx, paintValue.current);
                }
            };

            const renderShape = (type, col) => {
                if (type === 0) return null;
                if (type === 1) return <div className="w-full h-full" style={{backgroundColor: col}}/>;
                
                // SVG Shapes for slopes
                let pts = "";
                // 2: Bottom-Left, 3: Bottom-Right, 4: Top-Right, 5: Top-Left
                if (type === 2) pts = "0,0 0,32 32,32"; 
                else if (type === 3) pts = "32,0 32,32 0,32"; 
                else if (type === 4) pts = "0,0 32,0 32,32"; 
                else if (type === 5) pts = "0,32 0,0 32,0"; 
                
                return <svg viewBox="0 0 32 32" className="w-full h-full block"><polygon points={pts} fill={col} /></svg>;
            };

            return (
                <div className="flex flex-col items-center">
                    <div className="mb-2 font-black uppercase text-xs tracking-widest bg-black text-white px-3 py-1 shadow-md">{title}</div>
                    <div 
                        className="grid bg-white border-2 border-black shadow-[4px_4px_0px_0px_rgba(0,0,0,0.2)]"
                        style={{ gridTemplateColumns: `repeat(${resolution}, minmax(0, 1fr))` }}
                    >
                        {data.cells.map((val, i) => {
                            // Check if this cell actually contributes to a voxel (validityMask)
                            // If validityMask is false, it means this cell doesn't intersect with other views to form a block
                            const isValid = validityMask ? validityMask[i] : true;
                            const showWarning = val > 0 && !isValid;

                            return (
                                <div 
                                    key={i} 
                                    onMouseDown={() => handleMouseDown(i)}
                                    onMouseEnter={() => handleMouseEnter(i)}
                                    className="w-6 h-6 sm:w-8 sm:h-8 border border-gray-100 cursor-pointer relative flex items-center justify-center hover:bg-gray-50 transition-colors"
                                >
                                    {renderShape(val, showWarning ? '#e5e7eb' : color)} 
                                    {/* Ghost indicator for valid position but empty */}
                                    {val === 0 && <div className="w-1 h-1 rounded-full bg-gray-200 opacity-0 hover:opacity-100"/>}
                                    
                                    {showWarning && (
                                        <div className="absolute inset-0 flex items-center justify-center opacity-30 pointer-events-none">
                                            <div className="w-full h-[1px] bg-red-500 absolute rotate-45"/>
                                            <div className="w-full h-[1px] bg-red-500 absolute -rotate-45"/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [resolution, setResolution] = useState(8);
            const [name, setName] = useState('');
            const [tool, setTool] = useState('cube'); // 'cube' | 'triangle'
            
            // Grids State
            const [grids, setGrids] = useState({
                alzado: createEmptyGridState(8),
                planta: createEmptyGridState(8),
                perfil: createEmptyGridState(8)
            });

            // Update grids when resolution changes
            useEffect(() => {
                setGrids({
                    alzado: createEmptyGridState(resolution),
                    planta: createEmptyGridState(resolution),
                    perfil: createEmptyGridState(resolution)
                });
            }, [resolution]);

            // Calculate Voxels automatically
            const voxels = useMemo(() => {
                return calculateVoxelsFromViews(
                    grids.alzado.cells,
                    grids.planta.cells,
                    grids.perfil.cells,
                    resolution
                );
            }, [grids, resolution]);

            // Validity Mask: Calculate which 2D cells successfully created a voxel
            // This helps show users "Ghost" cells that don't match other views
            const validityMask = useMemo(() => {
                const numCells = resolution * resolution;
                const mask = {
                    alzado: new Array(numCells).fill(false),
                    planta: new Array(numCells).fill(false),
                    perfil: new Array(numCells).fill(false)
                };
                
                const activeVoxels = voxels;
                
                activeVoxels.forEach(([x, y, z]) => {
                    mask.alzado[(resolution - 1 - y) * resolution + x] = true;
                    mask.planta[z * resolution + x] = true;
                    mask.perfil[(resolution - 1 - y) * resolution + (resolution - 1 - z)] = true;
                });
                return mask;
            }, [voxels, resolution]);

            const handleCellClick = (view, idx, val) => {
                setGrids(prev => {
                    const newCells = [...prev[view].cells];
                    newCells[idx] = val;
                    return { ...prev, [view]: { ...prev[view], cells: newCells } };
                });
            };

            const clearAll = () => {
                if(confirm("¿Borrar todo el dibujo?")) {
                    setGrids({
                        alzado: createEmptyGridState(resolution),
                        planta: createEmptyGridState(resolution),
                        perfil: createEmptyGridState(resolution)
                    });
                }
            };

            const handleExport = async (type) => {
                const filenameName = name.trim() || 'mi-dibujo';
                
                if (type === 'iso') {
                    // Capture 3D Canvas
                    const canvas = document.querySelector('canvas');
                    if (canvas) {
                        const link = document.createElement('a');
                        link.download = `${filenameName}-isometrica.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    }
                } else if (type === 'plans') {
                    // Capture HTML Grid Area
                    const element = document.getElementById('grid-container');
                    if (element) {
                        const canvas = await html2canvas(element, { backgroundColor: '#ffffff', scale: 2 });
                        const link = document.createElement('a');
                        link.download = `${filenameName}-vistas.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    }
                }
            };

            return (
                <div className="flex flex-col h-screen font-sans text-slate-800">
                    {/* Header */}
                    <header className="bg-white border-b border-gray-200 px-6 py-3 flex items-center justify-between shadow-sm z-20 h-16 shrink-0">
                        <div className="flex items-center gap-3">
                            <div className="bg-black text-white p-2 rounded-md shadow-sm"><Box size={20} strokeWidth={3}/></div>
                            <div>
                                <h1 className="text-xl font-black uppercase tracking-tight">Diédrico Creator</h1>
                                <p className="text-xs text-gray-500 font-medium">Diseña tu Inicial / Nombre</p>
                            </div>
                        </div>

                        <div className="flex items-center gap-6">
                            {/* Name Input */}
                            <div className="flex items-center bg-gray-100 rounded-lg px-3 py-1.5 border border-transparent focus-within:border-black focus-within:bg-white transition-all">
                                <Type size={16} className="text-gray-400 mr-2"/>
                                <input 
                                    type="text" 
                                    placeholder="Tu Nombre" 
                                    value={name} 
                                    onChange={e => setName(e.target.value)}
                                    className="bg-transparent border-none outline-none text-sm font-bold w-32 md:w-48 placeholder-gray-400"
                                />
                            </div>

                            {/* Export Buttons */}
                            <div className="flex gap-2">
                                <button onClick={() => handleExport('iso')} className="flex items-center gap-2 px-3 py-1.5 bg-white border border-gray-300 rounded hover:bg-gray-50 text-xs font-bold transition-colors">
                                    <Camera size={16} className="text-purple-600"/> <span className="hidden sm:inline">Guardar Isométrica</span>
                                </button>
                                <button onClick={() => handleExport('plans')} className="flex items-center gap-2 px-3 py-1.5 bg-white border border-gray-300 rounded hover:bg-gray-50 text-xs font-bold transition-colors">
                                    <ImageIcon size={16} className="text-blue-600"/> <span className="hidden sm:inline">Guardar Vistas</span>
                                </button>
                            </div>
                        </div>
                    </header>

                    {/* Main Content */}
                    <div className="flex flex-1 overflow-hidden">
                        
                        {/* LEFT: 3D View */}
                        <div className="w-1/2 lg:w-5/12 bg-gray-50 border-r border-gray-200 relative flex flex-col">
                            <div className="absolute top-4 left-4 z-10 bg-white/90 backdrop-blur px-3 py-2 rounded-lg border border-gray-200 shadow-sm text-xs font-medium flex items-center gap-2">
                                <MousePointer2 size={14}/> <span>Rotar: Arrastrar clic izq.</span>
                            </div>
                            <div className="flex-1 relative">
                                <VoxelViewer 
                                    voxels={voxels} 
                                    gridResolution={resolution} 
                                />
                            </div>
                            
                            {/* Legend */}
                            <div className="bg-white border-t border-gray-200 p-3 shrink-0">
                                <div className="flex justify-between items-center mb-2">
                                    <h4 className="font-bold text-xs uppercase text-gray-400 flex items-center gap-1"><Info size={12}/> Leyenda</h4>
                                </div>
                                <div className="flex flex-wrap gap-2">
                                    {[
                                        {l:'Planta', c:PALETTE.FACE_TOP}, 
                                        {l:'Alzado', c:PALETTE.FACE_FRONT}, 
                                        {l:'Perfil', c:PALETTE.FACE_SIDE}
                                    ].map((x,i) => (
                                        <div key={i} className="flex items-center gap-1.5 bg-gray-50 px-2 py-1 rounded border border-gray-100">
                                            <div className="w-3 h-3 rounded-sm shadow-sm" style={{background: x.c}}></div>
                                            <span className="text-[10px] font-bold uppercase">{x.l}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>

                        {/* RIGHT: Drawing Grid */}
                        <div className="w-1/2 lg:w-7/12 bg-white flex flex-col relative">
                            {/* Toolbar */}
                            <div className="h-16 shrink-0 border-b border-gray-100 flex items-center justify-center gap-8 px-4">
                                {/* Tool Selector */}
                                <div className="flex bg-gray-100 p-1 rounded-lg">
                                    <button 
                                        onClick={() => setTool('cube')}
                                        className={`flex items-center gap-2 px-4 py-1.5 rounded-md text-xs font-bold transition-all ${tool === 'cube' ? 'bg-white text-black shadow-sm' : 'text-gray-500 hover:text-gray-700'}`}
                                    >
                                        <Box size={16}/> BLOQUE
                                    </button>
                                    <button 
                                        onClick={() => setTool('triangle')}
                                        className={`flex items-center gap-2 px-4 py-1.5 rounded-md text-xs font-bold transition-all ${tool === 'triangle' ? 'bg-white text-black shadow-sm' : 'text-gray-500 hover:text-gray-700'}`}
                                    >
                                        <Triangle size={16}/> RAMPA
                                    </button>
                                </div>

                                {/* Resolution */}
                                <div className="flex items-center gap-3 bg-gray-50 px-4 py-1.5 rounded-lg border border-gray-100">
                                    <span className="text-[10px] font-black uppercase text-gray-400">Tamaño</span>
                                    <input 
                                        type="range" 
                                        min="4" max="12" step="1"
                                        value={resolution} 
                                        onChange={(e) => setResolution(parseInt(e.target.value))}
                                        className="w-20 accent-black h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                                    />
                                    <span className="text-xs font-bold w-6">{resolution}</span>
                                </div>

                                <button onClick={clearAll} className="p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors" title="Borrar todo">
                                    <Trash2 size={18}/>
                                </button>
                            </div>

                            {/* Grids Container */}
                            <div className="flex-1 overflow-y-auto bg-slate-50 p-6 flex items-center justify-center">
                                <div id="grid-container" className="bg-white p-8 rounded-xl shadow-sm border border-gray-200">
                                    <div className="grid grid-cols-2 gap-8">
                                        <ProjectionGrid 
                                            title="ALZADO (Frente)" 
                                            color={PALETTE.FACE_FRONT} 
                                            data={grids.alzado} 
                                            resolution={resolution}
                                            tool={tool}
                                            onCellClick={(i, v) => handleCellClick('alzado', i, v)}
                                            validityMask={validityMask.alzado}
                                        />
                                        <ProjectionGrid 
                                            title="PERFIL (Lateral)" 
                                            color={PALETTE.FACE_SIDE} 
                                            data={grids.perfil} 
                                            resolution={resolution}
                                            tool={tool}
                                            onCellClick={(i, v) => handleCellClick('perfil', i, v)}
                                            validityMask={validityMask.perfil}
                                        />
                                        <ProjectionGrid 
                                            title="PLANTA (Arriba)" 
                                            color={PALETTE.FACE_TOP} 
                                            data={grids.planta} 
                                            resolution={resolution}
                                            tool={tool}
                                            onCellClick={(i, v) => handleCellClick('planta', i, v)}
                                            validityMask={validityMask.planta}
                                        />
                                        
                                        {/* Instructions / Helper */}
                                        <div className="flex flex-col justify-center text-sm text-gray-500 p-4 border-2 border-dashed border-gray-200 rounded-lg bg-gray-50">
                                            <p className="font-bold text-black mb-2 flex items-center gap-2"><Info size={16}/> ¿Cómo funciona?</p>
                                            <ul className="list-disc list-inside space-y-1 text-xs">
                                                <li>Dibuja en las 3 vistas para crear cubos.</li>
                                                <li>Un cubo solo aparece si existe en las 3 proyecciones.</li>
                                                <li>Si dibujas algo en Planta pero no en Alzado, aparecerá gris (inválido).</li>
                                                <li>Usa la herramienta <b>Rampa</b> y haz clic varias veces para rotar la inclinación.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
